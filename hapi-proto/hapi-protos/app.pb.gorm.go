package hapi_protos

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	types "github.com/infobloxopen/protoc-gen-gorm/types"
	go_uuid "github.com/satori/go.uuid"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	gorm "gorm.io/gorm"
	strings "strings"
	time "time"
)

type HappyAppORM struct {
	CreatedAt *time.Time   `gorm:"not null"`
	HappyRoot string       `gorm:"not null"`
	Id        go_uuid.UUID `gorm:"type:uuid;primaryKey;default:gen_random_uuid();not null"`
	Name      string       `gorm:"not null"`
	RepoSlug  string       `gorm:"not null"`
	UpdatedAt *time.Time   `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (HappyAppORM) TableName() string {
	return "happy_apps"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *HappyApp) ToORM(ctx context.Context) (HappyAppORM, error) {
	to := HappyAppORM{}
	var err error
	if prehook, ok := interface{}(m).(HappyAppWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id, err = go_uuid.FromString(m.Id.Value)
		if err != nil {
			return to, err
		}
	} else {
		to.Id = go_uuid.Nil
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.Name = m.Name
	to.RepoSlug = m.RepoSlug
	to.HappyRoot = m.HappyRoot
	if posthook, ok := interface{}(m).(HappyAppWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HappyAppORM) ToPB(ctx context.Context) (HappyApp, error) {
	to := HappyApp{}
	var err error
	if prehook, ok := interface{}(m).(HappyAppWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = &types.UUID{Value: m.Id.String()}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.Name = m.Name
	to.RepoSlug = m.RepoSlug
	to.HappyRoot = m.HappyRoot
	if posthook, ok := interface{}(m).(HappyAppWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type HappyApp the arg will be the target, the caller the one being converted from

// HappyAppBeforeToORM called before default ToORM code
type HappyAppWithBeforeToORM interface {
	BeforeToORM(context.Context, *HappyAppORM) error
}

// HappyAppAfterToORM called after default ToORM code
type HappyAppWithAfterToORM interface {
	AfterToORM(context.Context, *HappyAppORM) error
}

// HappyAppBeforeToPB called before default ToPB code
type HappyAppWithBeforeToPB interface {
	BeforeToPB(context.Context, *HappyApp) error
}

// HappyAppAfterToPB called after default ToPB code
type HappyAppWithAfterToPB interface {
	AfterToPB(context.Context, *HappyApp) error
}

type HappyStackORM struct {
	CreatedAt          *time.Time   `gorm:"not null"`
	HappyApp           *HappyAppORM `gorm:"not null;foreignKey:HappyAppId;references:Id"`
	HappyAppId         *go_uuid.UUID
	HappyEnv           *HappyEnvironmentORM `gorm:"not null;foreignKey:HappyEnvironmentId;references:Id"`
	HappyEnvironmentId *go_uuid.UUID
	Id                 go_uuid.UUID `gorm:"type:uuid;primaryKey;default:gen_random_uuid();not null"`
	Name               string       `gorm:"not null"`
	UpdatedAt          *time.Time   `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (HappyStackORM) TableName() string {
	return "happy_stacks"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *HappyStack) ToORM(ctx context.Context) (HappyStackORM, error) {
	to := HappyStackORM{}
	var err error
	if prehook, ok := interface{}(m).(HappyStackWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id, err = go_uuid.FromString(m.Id.Value)
		if err != nil {
			return to, err
		}
	} else {
		to.Id = go_uuid.Nil
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.Name = m.Name
	if m.HappyApp != nil {
		tempHappyApp, err := m.HappyApp.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.HappyApp = &tempHappyApp
	}
	if m.HappyEnv != nil {
		tempHappyEnv, err := m.HappyEnv.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.HappyEnv = &tempHappyEnv
	}
	if posthook, ok := interface{}(m).(HappyStackWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HappyStackORM) ToPB(ctx context.Context) (HappyStack, error) {
	to := HappyStack{}
	var err error
	if prehook, ok := interface{}(m).(HappyStackWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = &types.UUID{Value: m.Id.String()}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.Name = m.Name
	if m.HappyApp != nil {
		tempHappyApp, err := m.HappyApp.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.HappyApp = &tempHappyApp
	}
	if m.HappyEnv != nil {
		tempHappyEnv, err := m.HappyEnv.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.HappyEnv = &tempHappyEnv
	}
	if posthook, ok := interface{}(m).(HappyStackWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type HappyStack the arg will be the target, the caller the one being converted from

// HappyStackBeforeToORM called before default ToORM code
type HappyStackWithBeforeToORM interface {
	BeforeToORM(context.Context, *HappyStackORM) error
}

// HappyStackAfterToORM called after default ToORM code
type HappyStackWithAfterToORM interface {
	AfterToORM(context.Context, *HappyStackORM) error
}

// HappyStackBeforeToPB called before default ToPB code
type HappyStackWithBeforeToPB interface {
	BeforeToPB(context.Context, *HappyStack) error
}

// HappyStackAfterToPB called after default ToPB code
type HappyStackWithAfterToPB interface {
	AfterToPB(context.Context, *HappyStack) error
}

type HappyEnvironmentORM struct {
	ComputeArn      string       `gorm:"not null"`
	CreatedAt       *time.Time   `gorm:"not null"`
	DeloymentStage  string       `gorm:"not null"`
	Id              go_uuid.UUID `gorm:"type:uuid;primaryKey;default:gen_random_uuid();not null"`
	LaunchType      int32        `gorm:"not null"`
	Namespace       string       `gorm:"not null"`
	OtherLaunchType *string      `gorm:"not null"`
	UpdatedAt       *time.Time   `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (HappyEnvironmentORM) TableName() string {
	return "happy_environments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *HappyEnvironment) ToORM(ctx context.Context) (HappyEnvironmentORM, error) {
	to := HappyEnvironmentORM{}
	var err error
	if prehook, ok := interface{}(m).(HappyEnvironmentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id, err = go_uuid.FromString(m.Id.Value)
		if err != nil {
			return to, err
		}
	} else {
		to.Id = go_uuid.Nil
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.DeloymentStage = m.DeloymentStage
	to.LaunchType = int32(m.LaunchType)
	to.OtherLaunchType = m.OtherLaunchType
	to.Namespace = m.Namespace
	to.ComputeArn = m.ComputeArn
	if posthook, ok := interface{}(m).(HappyEnvironmentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HappyEnvironmentORM) ToPB(ctx context.Context) (HappyEnvironment, error) {
	to := HappyEnvironment{}
	var err error
	if prehook, ok := interface{}(m).(HappyEnvironmentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = &types.UUID{Value: m.Id.String()}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.DeloymentStage = m.DeloymentStage
	to.LaunchType = HappyEnvLaunchType(m.LaunchType)
	to.OtherLaunchType = m.OtherLaunchType
	to.Namespace = m.Namespace
	to.ComputeArn = m.ComputeArn
	if posthook, ok := interface{}(m).(HappyEnvironmentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type HappyEnvironment the arg will be the target, the caller the one being converted from

// HappyEnvironmentBeforeToORM called before default ToORM code
type HappyEnvironmentWithBeforeToORM interface {
	BeforeToORM(context.Context, *HappyEnvironmentORM) error
}

// HappyEnvironmentAfterToORM called after default ToORM code
type HappyEnvironmentWithAfterToORM interface {
	AfterToORM(context.Context, *HappyEnvironmentORM) error
}

// HappyEnvironmentBeforeToPB called before default ToPB code
type HappyEnvironmentWithBeforeToPB interface {
	BeforeToPB(context.Context, *HappyEnvironment) error
}

// HappyEnvironmentAfterToPB called after default ToPB code
type HappyEnvironmentWithAfterToPB interface {
	AfterToPB(context.Context, *HappyEnvironment) error
}

// DefaultCreateHappyApp executes a basic gorm create call
func DefaultCreateHappyApp(ctx context.Context, in *HappyApp, db *gorm.DB) (*HappyApp, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyAppORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyAppORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HappyAppORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyAppORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadHappyApp(ctx context.Context, in *HappyApp, db *gorm.DB) (*HappyApp, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HappyAppORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HappyAppORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := HappyAppORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HappyAppORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HappyAppORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyAppORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyAppORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteHappyApp(ctx context.Context, in *HappyApp, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == go_uuid.Nil {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HappyAppORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HappyAppORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HappyAppORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HappyAppORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyAppORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteHappyAppSet(ctx context.Context, in []*HappyApp, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []go_uuid.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == go_uuid.Nil {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&HappyAppORM{})).(HappyAppORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&HappyAppORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HappyAppORM{})).(HappyAppORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HappyAppORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*HappyApp, *gorm.DB) (*gorm.DB, error)
}
type HappyAppORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*HappyApp, *gorm.DB) error
}

// DefaultStrictUpdateHappyApp clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHappyApp(ctx context.Context, in *HappyApp, db *gorm.DB) (*HappyApp, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHappyApp")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &HappyAppORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HappyAppORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HappyAppORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyAppORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HappyAppORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyAppORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyAppORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchHappyApp executes a basic gorm update call with patch behavior
func DefaultPatchHappyApp(ctx context.Context, in *HappyApp, updateMask *field_mask.FieldMask, db *gorm.DB) (*HappyApp, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj HappyApp
	var err error
	if hook, ok := interface{}(&pbObj).(HappyAppWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadHappyApp(ctx, &HappyApp{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(HappyAppWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHappyApp(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HappyAppWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHappyApp(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HappyAppWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HappyAppWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *HappyApp, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HappyAppWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *HappyApp, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HappyAppWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *HappyApp, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HappyAppWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *HappyApp, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetHappyApp executes a bulk gorm update call with patch behavior
func DefaultPatchSetHappyApp(ctx context.Context, objects []*HappyApp, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*HappyApp, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*HappyApp, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHappyApp(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHappyApp patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHappyApp(ctx context.Context, patchee *HappyApp, patcher *HappyApp, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*HappyApp, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"RepoSlug" {
			patchee.RepoSlug = patcher.RepoSlug
			continue
		}
		if f == prefix+"HappyRoot" {
			patchee.HappyRoot = patcher.HappyRoot
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHappyApp executes a gorm list call
func DefaultListHappyApp(ctx context.Context, db *gorm.DB) ([]*HappyApp, error) {
	in := HappyApp{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyAppORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HappyAppORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []HappyAppORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyAppORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*HappyApp{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HappyAppORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyAppORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyAppORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]HappyAppORM) error
}

// DefaultCreateHappyStack executes a basic gorm create call
func DefaultCreateHappyStack(ctx context.Context, in *HappyStack, db *gorm.DB) (*HappyStack, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyStackORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyStackORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HappyStackORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyStackORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadHappyStack(ctx context.Context, in *HappyStack, db *gorm.DB) (*HappyStack, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HappyStackORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HappyStackORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := HappyStackORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HappyStackORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HappyStackORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyStackORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyStackORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteHappyStack(ctx context.Context, in *HappyStack, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == go_uuid.Nil {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HappyStackORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HappyStackORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HappyStackORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HappyStackORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyStackORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteHappyStackSet(ctx context.Context, in []*HappyStack, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []go_uuid.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == go_uuid.Nil {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&HappyStackORM{})).(HappyStackORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&HappyStackORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HappyStackORM{})).(HappyStackORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HappyStackORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*HappyStack, *gorm.DB) (*gorm.DB, error)
}
type HappyStackORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*HappyStack, *gorm.DB) error
}

// DefaultStrictUpdateHappyStack clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHappyStack(ctx context.Context, in *HappyStack, db *gorm.DB) (*HappyStack, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHappyStack")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &HappyStackORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HappyStackORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HappyStackORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyStackORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HappyStackORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyStackORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyStackORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchHappyStack executes a basic gorm update call with patch behavior
func DefaultPatchHappyStack(ctx context.Context, in *HappyStack, updateMask *field_mask.FieldMask, db *gorm.DB) (*HappyStack, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj HappyStack
	var err error
	if hook, ok := interface{}(&pbObj).(HappyStackWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadHappyStack(ctx, &HappyStack{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(HappyStackWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHappyStack(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HappyStackWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHappyStack(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HappyStackWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HappyStackWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *HappyStack, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HappyStackWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *HappyStack, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HappyStackWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *HappyStack, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HappyStackWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *HappyStack, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetHappyStack executes a bulk gorm update call with patch behavior
func DefaultPatchSetHappyStack(ctx context.Context, objects []*HappyStack, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*HappyStack, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*HappyStack, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHappyStack(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHappyStack patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHappyStack(ctx context.Context, patchee *HappyStack, patcher *HappyStack, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*HappyStack, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedHappyApp bool
	var updatedHappyEnv bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if !updatedHappyApp && strings.HasPrefix(f, prefix+"HappyApp.") {
			updatedHappyApp = true
			if patcher.HappyApp == nil {
				patchee.HappyApp = nil
				continue
			}
			if patchee.HappyApp == nil {
				patchee.HappyApp = &HappyApp{}
			}
			if o, err := DefaultApplyFieldMaskHappyApp(ctx, patchee.HappyApp, patcher.HappyApp, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"HappyApp.", db); err != nil {
				return nil, err
			} else {
				patchee.HappyApp = o
			}
			continue
		}
		if f == prefix+"HappyApp" {
			updatedHappyApp = true
			patchee.HappyApp = patcher.HappyApp
			continue
		}
		if !updatedHappyEnv && strings.HasPrefix(f, prefix+"HappyEnv.") {
			updatedHappyEnv = true
			if patcher.HappyEnv == nil {
				patchee.HappyEnv = nil
				continue
			}
			if patchee.HappyEnv == nil {
				patchee.HappyEnv = &HappyEnvironment{}
			}
			if o, err := DefaultApplyFieldMaskHappyEnvironment(ctx, patchee.HappyEnv, patcher.HappyEnv, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"HappyEnv.", db); err != nil {
				return nil, err
			} else {
				patchee.HappyEnv = o
			}
			continue
		}
		if f == prefix+"HappyEnv" {
			updatedHappyEnv = true
			patchee.HappyEnv = patcher.HappyEnv
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHappyStack executes a gorm list call
func DefaultListHappyStack(ctx context.Context, db *gorm.DB) ([]*HappyStack, error) {
	in := HappyStack{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyStackORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HappyStackORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []HappyStackORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyStackORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*HappyStack{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HappyStackORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyStackORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyStackORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]HappyStackORM) error
}

// DefaultCreateHappyEnvironment executes a basic gorm create call
func DefaultCreateHappyEnvironment(ctx context.Context, in *HappyEnvironment, db *gorm.DB) (*HappyEnvironment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyEnvironmentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyEnvironmentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HappyEnvironmentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyEnvironmentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadHappyEnvironment(ctx context.Context, in *HappyEnvironment, db *gorm.DB) (*HappyEnvironment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == go_uuid.Nil {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HappyEnvironmentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HappyEnvironmentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := HappyEnvironmentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HappyEnvironmentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HappyEnvironmentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyEnvironmentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyEnvironmentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteHappyEnvironment(ctx context.Context, in *HappyEnvironment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == go_uuid.Nil {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HappyEnvironmentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HappyEnvironmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HappyEnvironmentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HappyEnvironmentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyEnvironmentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteHappyEnvironmentSet(ctx context.Context, in []*HappyEnvironment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []go_uuid.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == go_uuid.Nil {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&HappyEnvironmentORM{})).(HappyEnvironmentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&HappyEnvironmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HappyEnvironmentORM{})).(HappyEnvironmentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HappyEnvironmentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*HappyEnvironment, *gorm.DB) (*gorm.DB, error)
}
type HappyEnvironmentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*HappyEnvironment, *gorm.DB) error
}

// DefaultStrictUpdateHappyEnvironment clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHappyEnvironment(ctx context.Context, in *HappyEnvironment, db *gorm.DB) (*HappyEnvironment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHappyEnvironment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &HappyEnvironmentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HappyEnvironmentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HappyEnvironmentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyEnvironmentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HappyEnvironmentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyEnvironmentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyEnvironmentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchHappyEnvironment executes a basic gorm update call with patch behavior
func DefaultPatchHappyEnvironment(ctx context.Context, in *HappyEnvironment, updateMask *field_mask.FieldMask, db *gorm.DB) (*HappyEnvironment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj HappyEnvironment
	var err error
	if hook, ok := interface{}(&pbObj).(HappyEnvironmentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadHappyEnvironment(ctx, &HappyEnvironment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(HappyEnvironmentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHappyEnvironment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HappyEnvironmentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHappyEnvironment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HappyEnvironmentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HappyEnvironmentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *HappyEnvironment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HappyEnvironmentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *HappyEnvironment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HappyEnvironmentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *HappyEnvironment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HappyEnvironmentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *HappyEnvironment, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetHappyEnvironment executes a bulk gorm update call with patch behavior
func DefaultPatchSetHappyEnvironment(ctx context.Context, objects []*HappyEnvironment, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*HappyEnvironment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*HappyEnvironment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHappyEnvironment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHappyEnvironment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHappyEnvironment(ctx context.Context, patchee *HappyEnvironment, patcher *HappyEnvironment, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*HappyEnvironment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeloymentStage" {
			patchee.DeloymentStage = patcher.DeloymentStage
			continue
		}
		if f == prefix+"LaunchType" {
			patchee.LaunchType = patcher.LaunchType
			continue
		}
		if f == prefix+"OtherLaunchType" {
			patchee.OtherLaunchType = patcher.OtherLaunchType
			continue
		}
		if f == prefix+"Namespace" {
			patchee.Namespace = patcher.Namespace
			continue
		}
		if f == prefix+"ComputeArn" {
			patchee.ComputeArn = patcher.ComputeArn
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHappyEnvironment executes a gorm list call
func DefaultListHappyEnvironment(ctx context.Context, db *gorm.DB) ([]*HappyEnvironment, error) {
	in := HappyEnvironment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyEnvironmentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HappyEnvironmentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []HappyEnvironmentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HappyEnvironmentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*HappyEnvironment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HappyEnvironmentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyEnvironmentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HappyEnvironmentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]HappyEnvironmentORM) error
}
